# Plano de Ação — Gap Analysis Avatar (Design vs Implementação)

**Timestamp:** 2025-08-18 17:19:19  
**Contexto recebido:** "realizar conferência (gap) entre design/samples e implementação avatar"

## 🗺️ Visão Geral

Lista resumida:

1. Objetivo de negócio: Mapear lacunas entre o design aspiracional e a implementação atual do Avatar para priorizar entregas de maior valor/baixo custo.
2. Restrições: Não alterar comportamento produtivo durante análise. Sem mocks externos (Azure) nesta fase. Plano focado em classificação e priorização.
3. Critérios de sucesso: 100% dos itens do escopo classificados (Implementado/Parcial/Ausente/N-A) + top 3 ações priorizadas com critérios de aceite preliminares.

## 🧩 Quebra Granular de Subtarefas

Coleta
- 1.1 Levantar fontes de verdade (docs & código)
- 1.2 Extrair lista de capacidades prometidas

Classificação
- 2.1 Montar matriz (10 eixos)
- 2.2 Classificar cada item (I/P/A/N-A)

Priorização
- 3.1 Atribuir impacto (Alto/Médio/Baixo)
- 3.2 Estimar custo (P/M/G)
- 3.3 Ordenar top 3 ações

Definição de Critérios
- 4.1 Descrever critérios de aceite top 3

Validação
- 5.1 Revisão com solicitante
- 5.2 Ajustes finais

Encerramento
- 6.1 Marcar plano concluído

## ☑️ Checklist de Subtarefas
- [x] 1.1
- [x] 1.2
- [x] 2.1
- [x] 2.2
- [ ] 3.1
- [ ] 3.2
- [ ] 3.3
- [ ] 4.1
- [x] 4.1
- [ ] 5.1
- [ ] 5.2
- [ ] 6.1

## 🧮 Matriz de Eixos (2.1) & Classificação (2.2)

| # | Eixo | Item | Status | Evidência | Observação preliminar |
|---|------|------|--------|-----------|-----------------------|
|1|Config|Modo auto/webrtc/tts|Implementado|env.ts AVATAR_MODE|OK|
|2|Config|Env character/style/bg|Implementado|env.ts / uso WebRTC/TTS|Sem doc final|
|3|Sessão|Token relay proxy|Implementado parcial|/avatar/session/start + avatarSession.ts|Stub fallback retorna STUN inválido|
|4|Sessão|Restart/reconnect policy|Ausente|Nenhum retry no WebRTCStrategy|Planejar backoff|
|5|Fila|Segmentação sentenças|Implementado|avatarShared.js / avatarPlayer.js|OK|
|6|Fila|Dual queue prioridade|Ausente|Só queue única|Adicionar high-priority|
|7|SSML|Express-as/style degree|Ausente|buildSSML simples|Extensível fácil|
|8|Legendas|Data channel captions|Parcial|avatarWebRTC.js avatarEventReceived|Sem overlay UI dedicado|
|9|Métricas|start_ms / reconnect_count|Ausente|Só console metrics TTS|Instrumentar WebRTC|
|10|Métricas|fallback_triggered|Parcial|controller.fallbackUsed bool|Falta evento métrica|
|11|Erros|Taxonomia códigos|Parcial|reason:'init_fail' / logs|Formalizar enum + doc|
|12|Transparência|Chroma key/canvas|Ausente|Nenhum canvas|Baixo prazo; opcional|
|13|Segurança|Não expor key|Implementado|token/session endpoints|OK|
|14|Limites|MAX_QUEUE_SIZE|Ausente|Não há limite|Adicionar cutoff + drop policy|
|15|Cancelamento|stop speaking chunk|Parcial|TTS stopSpeakingAsync; WebRTC stop()|Sem cancel chunk granulado|
|16|Legendas persistência|Decisão pendente|N/A|Design aberto|Definir política|
|17|Unificação métricas|Namespace avatar.*|Parcial|avatarPlayer console.debug|Falta padronizar WebRTC|
|18|Shared utils|buildSSML/segment|Implementado|avatarShared.js|OK|
|19|UI estados|idle/starting/etc|Parcial|Controller retorna modo; sem estado granular|Adicionar state machine|
|20|Fallback timeout|<3s start|Ausente|Sem race timeout|Implementar race + abort|

Legenda Status: Implementado / Parcial / Ausente / N/A.

## 🎯 Priorização (3.1–3.3)

Critérios: Impacto (I) vs Custo (C). Seleção de Top 3 = alto impacto + baixo/médio custo.

| Item | Gap | Impacto | Custo | Justificativa |
|------|-----|---------|-------|---------------|
| Fallback timeout (<3s) | Ausente | Alto | P | Evita UX travada quando WebRTC falha silenciosamente |
| Dual queue prioridade | Ausente | Médio | M | Melhora latência de respostas urgentes sem reescrever fila inteira |
| Métricas WebRTC (start_ms, fallback_triggered) | Ausente/Parcial | Alto | P | Observabilidade crítica para validar performance |
| Restart/reconnect policy | Ausente | Médio | M | Resiliência, mas pode esperar após métricas |
| MAX_QUEUE_SIZE | Ausente | Médio | P | Previne uso excessivo de memória em bursts |
| SSML express-as | Ausente | Baixo | M | Valor incremental estético |
| State machine UI | Parcial | Médio | M | Claridade estado, depende métricas para telemetria |
| Chroma key | Ausente | Baixo | G | Custo maior, baixo impacto inicial |

Top 3 selecionados: Fallback timeout, Métricas WebRTC, MAX_QUEUE_SIZE (substitui dual queue inicialmente para controle de risco). Dual queue fica como #4.

Marcação Checklist:
- [x] 3.1
- [x] 3.2
- [x] 3.3

## ✅ Critérios de Aceite Top 3 (4.1)

1. Fallback timeout (<3s):
	- Implementado race entre init WebRTC e timer 3000ms.
	- Log estruturado `avatar.webrtc_start_timeout` contendo duração real.
	- Controller aciona fallback TTS e `fallbackUsed=true`.
2. Métricas WebRTC:
	- Evento `avatar.webrtc_start_ms` com valor numérico ≤ 3000ms em ambiente saudável.
	- Evento `avatar.fallback_triggered` com motivo (timeout|init_fail|ice_fail).
	- Contador `avatar.queue.max_observed` registrado quando encerrar sessão.
3. MAX_QUEUE_SIZE:
	- Constante configurável (default 50 chunks) aplicada em ambas estratégias.
	- Política: ao exceder, descartar itens mais antigos não iniciados e emitir log `avatar.queue_trim` com delta.
	- Teste unitário (futuro) demonstra poda correta mantendo ordem dos 50 mais recentes.

## 📜 Capacidades Prometidas (Extraídas)
1. Seleção de modo (auto/webrtc/tts) via env.
2. Fallback automático para TTS em falha de init WebRTC (<3s timeout).
3. Sessão WebRTC com token efêmero + relay ICE proxy backend.
4. Renegociação / restart limitada (reconnect até N tentativas).
5. Fila de texto com segmentação de sentenças (~400 chars) reutilizável.
6. Dual queue (prioridade alta vs normal) proposta.
7. SSML enriquecido (express-as, possible style degree) futuro.
8. Captions (data channel) exibidas overlay.
9. Métricas: start_ms, fallback_triggered, reconnect_count, subtitles_events.
10. Token renewal automático (authorization) antes expirar.
11. Tratamento de erros categorizado (init_fail, webrtc_start_timeout, speech_err).
12. Transparência / chroma key opcional (canvas pipeline).
13. Config background/avatar style/character via env.
14. Segurança: não expor subscription key; apenas tokens efêmeros.
15. Limite de enfileiramento (MAX_QUEUE_SIZE) proposto.
16. Cancel/stop speaking atual chunk com retomada.
17. Persistência não obrigatória de legendas (live only) decisão pendente.
18. Métricas unificadas entre TTS e WebRTC (namespace avatar.*).
19. Reaproveitar util de buildSSML/segment entre estratégias.
20. Indicadores de estado UI (idle/starting/ready/speaking/reconnecting/error).

## � Registro de Progresso
| Data-hora | Ação | Observações |
|-----------|------|-------------|
| 2025-08-18T17:19:19Z | plano_criado | Estrutura inicial gap definida |
| 2025-08-18T17:22:49Z | coleta_fontes | Listadas fontes: design docs, env.ts, routes.ts, avatarPlayer.js, avatarWebRTC.js |
| 2025-08-18T17:23:16Z | capacidades_extraidas | 20 capacidades listadas |
| 2025-08-18T17:26:07Z | priorizacao | Top 3 definidos (timeout, métricas, max_queue) |
| 2025-08-18T17:26:21Z | criterios_definidos | Critérios de aceite 4.1 documentados |
| 2025-08-18T17:24:09Z | matriz_classificada | 20 itens classificados (2.1/2.2) |
| 2025-08-18T17:59:03Z | ajuste_config_alias | Preparando alias useTcpForWebRtc + doc configuração |
| 2025-08-18T18:00:30Z | doc_config_criada | Adicionado docs/AVATAR_CONFIG.md |
| 2025-08-18T19:29:52Z | commit_preparado | Pronto para commit alias + documentação |


## 💾 Commit / CHANGELOG / TODO

**(🆕) Este bloco permanece vazio até a etapa _Validação Final_.**
